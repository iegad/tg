use criterion::{Criterion, criterion_group, criterion_main};

async fn tokio_mpsc() {
    use tokio::sync::mpsc;

    let (tx, mut wx) = mpsc::unbounded_channel();
    let mut arr = Vec::new();
    
    for _ in 0..2 {
        let txc = tx.clone();
        let f = tokio::spawn(async move {
            for i in 0..1000000 {
                let data = format!("1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890: {i}");
                txc.send(data).unwrap();
            }
        });
        arr.push(f);
    }

    for _ in 0..1000000 {
        let mut v = wx.recv().await.unwrap();
        v.clear();
    }

    futures_util::future::join_all(arr).await;
}

async fn futurl_mpsc() {
    use futures::channel::mpsc;

    let (tx, mut wx) = mpsc::unbounded();
    let mut arr = Vec::new();
    
    for _ in 0..2 {
        let txc = tx.clone();
        let f = tokio::spawn(async move {
            for i in 0..1000000 {
                let data = format!("1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890: {i}");
                txc.unbounded_send(data).unwrap();
            }
        });
        arr.push(f);
    }

    for _ in 0..1000000 {
        let mut v = wx.try_next().unwrap().unwrap();
        v.clear();
    }

    futures_util::future::join_all(arr).await;
}

fn chan_benchmark(c: &mut Criterion) {
    c.bench_function("tokio_mpsc", |b|b.iter(tokio_mpsc));
    c.bench_function("futurl_mpsc", |b|b.iter(futurl_mpsc));
}

criterion_group!(benches, chan_benchmark);
criterion_main!(benches);